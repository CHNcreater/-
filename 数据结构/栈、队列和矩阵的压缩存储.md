# 队列和栈
## 栈
  1. 逻辑结构
    栈是一种操作受限的数据结构，一般在逻辑上理解成只允许在一端进行插入和删除操作的线性表，
    ![栈](http://d.hiphotos.baidu.com/zhidao/pic/item/b3b7d0a20cf431adb8858b624936acaf2edd9812.jpg)  
    一般栈顶使用top来标识，初始值为-1，最大值为定义的栈的大小的最大值，栈只在栈顶处进行插入和删除操作，栈底是固定的，不发生变化。
    栈的基本操作有：  
      * InitStack(&S)//初始化一个空栈
      * StackEmpty(&S)//判断一个栈是否为空
      * Push(&S,x)//进栈，x成为新栈顶
      * Pop(&S,&x)//弹出栈顶元素，并用x返回
      * GetTop(S,&x)//用x返回栈顶元素
      * ClearStack(&S//销毁栈
  2. 存储结构  
    * 顺序栈
      * 顺序栈的实现
        ```
        typedef struct{
          int data[MAXSIZE];
          int top;
        }SqStack;
        ```
      * 数据操作
        * 判断栈满和栈空
          top = -1时代表栈空，top = MAXSIZE-1代表栈满
        * 基本操作
          * 入栈
            ```
            if(s.top<MAXSIZE){
              s.data[++s.top] = x;
            }
            else printf("overflow");
            ```
          * 出栈
            ```
            if (s.top>-1){
              x = s.data[s.top--];
            }
            else printf("empty");
            ```
   * 共享栈
      ![共享栈](http://images2015.cnblogs.com/blog/793218/201603/793218-20160308190357475-1215887723.png)  
      两端入栈，同时向栈中靠近，提高了栈的利用率，两个栈可以根据各自的需要自由调整各自栈的大小。  
     **共享栈的好处：节省存储空间，降低发生上溢的可能。**  
       判断共享栈满的条件，假设数组下标[0,n-1]，则初始值top2 = n,top1 = -1，则栈满条件为top2-top1 == 1
   * 链栈  
      ![链栈](http://images0.cnblogs.com/blog/521482/201308/05153510-c0c27dc2f65249c5b9507e53b76536c5.gif)   
     * 实现方式
        ```
        typedef struct{
          int data;
          struct LiStack *next;
        }LiStack;
        ```
      * 基本操作
        * 入栈
          ```
            s->next = top;
            top = s;
          ```
        * 出栈
          ```
            x = top->data;
            top = top->next;
          ```
## 队列
  队列也是一种操作受限的线性表结构，队列只允许在表的一端进行插入，在表的另一端进行删除，向队列中插入数据称为入队，删除数据称为出队。
  * 逻辑结构
    ![队列](http://images0.cnblogs.com/blog/521482/201308/05153631-a0db7f1197af4562b31d5b49edadf7ec.gif)  
    队列队首一般用r表示，队尾一般用f来表示。
  * 队列的基本操作
    * InitQueue(&Q)//初始化队列
    * QueueEmpty(&Q)//判断队列是否为空
    * EnQueue(&Q,x)//入队
    * DeQueue(&Q,&x)//出队
    * GetHead(Q,&x)//读队头元素
### 队列的顺序存储结构
  ![顺序队列](http://img5.imgtn.bdimg.com/it/u=710522110,2753621101&fm=26&gp=0.jpg)  
  * 抽象数据类型
    ```
    typedef struct{
      int data[MAXSIZE];
      int f,r;
    }SqQueue;
    ```
  * 判断队列空和满的条件
    f = r时代表队列为空，一般可能认为队列满的条件是r = MAXSIZE，但是这种判断方式显然并不严谨，这种情况下队列中仍然有可能存在一个元素，而且在数组中仍然存在可以存放数据的位置，这种溢出被称之为假溢出。为了解决**假溢出**的问题，就提出了循环队列的逻辑结构。
### 循环队列
  ![循环队列](http://img.qqzhi.com/upload/img_5_5623009D3249140794_23.jpg)  
  循环队列是如何判断队空和队满呢？
  * 队空：r = f
  * 队满：(r+1)%MAXSIZE = f
  * 入队：r = (r+1)%MAXSIZE
  * 出队：f = (f+1)%MAXSIZE
### 链式队列
  ![链式队列](http://p.ananas.chaoxing.com/star/1024_0/1388476971021bnnye.jpg)  
  * 抽象数据类型
  ```
  typedef struct{
    int data;
    struct LinkNode *next;
  }LinkNode;
  typedef struct{
    LinkNode *front,*rear;
  }LinkQueue;
  ```
  * 基本操作
    * 入队
      ```
        s->data = x;
        s->next = NULL;
        Q.rear->next = s;
        Q.rear = s;
      ```
    * 出队
      ```
        x = p->data;
        Q.front->next = p->next;
        free(p);
      ```
# 数组和数组的压缩存储
## 上下三角矩阵的压缩存储
## 稀疏矩阵
